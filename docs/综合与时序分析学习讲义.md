# 综合与时序分析学习讲义

本讲义介绍在 NPC 项目中做的 **逻辑综合** 和 **静态时序分析（STA）**：每个文件在做什么、为什么要这样设计、以及我们做了哪些修改及原因。目标读者是后端零基础的同学。

---

## 一、从 RTL 到“能跑的电路”：流程概览

你写的 Verilog（如 `ysyx_00000000.v`、`EXU.v`）是 **RTL（Register Transfer Level）**，描述的是“在时钟沿怎么算、怎么存”。计算机不能直接拿 RTL 去造芯片，需要先把 RTL 变成一张由 **具体逻辑门和触发器** 连成的网，再根据工艺去做布局布线、流片。中间有两步和我们这次有关：

1. **综合（Synthesis）**：把 RTL 变成由“与门、或门、MUX、D 触发器等”组成的 **门级网表**。
2. **静态时序分析（STA）**：根据门和线的延时，算在给定时钟下，**最慢的那条路径** 是否能在下一个时钟沿前稳定，即 **时序是否满足**。

我们用的工具是：
- **Yosys**：做综合，把 RTL 转成门级网表；
- **OpenSTA**：做 STA，读网表 + 单元库 + 时钟约束，报告 slack、关键路径等。

下面分开讲：综合做什么、STA 做什么，然后按 **文件** 说明各自作用和修改原因。

---

## 二、综合（Synthesis）在做什么

### 2.1 综合的输入和输出

- **输入**：RTL（Verilog），例如 `always @(posedge clk) q <= d`、`assign y = a & b`。
- **输出**：**门级网表**。网表里不再有 `always`、`assign` 这种“行为”，而是一个个 **单元（cell）** 的实例和它们之间的连线，例如：
  - “这里放一个二输入与门 AND2，A 接 net1，B 接 net2，Y 接 net3”；
  - “这里放一个 D 触发器 DFF，D 接 net4，C 接 clock，Q 接 net5”。

这些 AND2、DFF 等，是 **抽象的逻辑单元**，还没对应到某个工艺的物理器件，但已经足够做 **逻辑等效** 和 **延时/时序估算**。

### 2.2 综合的大致步骤（和 `synth.ys` 的对应关系）

| 步骤 | 在 Yosys 里的大致含义 | 对应脚本/命令 |
|------|------------------------|---------------|
| 读入 RTL | 解析 Verilog，变成内部图 | `read_verilog` |
| 层次与顶层 | 确定顶层模块、用到的子模块 | `hierarchy -check -top ysyx_00000000` |
| 过程块转电路 | 把 `always`、`if/else` 等变成选择器、寄存器 | `proc` |
| 展平 | 把层次打平，变成一个大的扁平网表 | `flatten` |
| 逻辑优化 | 合并、化简冗余逻辑 | `opt` |
| 技术映射 | 把抽象的 $add、$mux 等映射到 **二输入与门、或门、MUX、D 触发器等** 小单元 | `techmap` |
| 再优化 | 映射后再做一次优化 | `opt` |
| 写出网表 | 把结果写成 Verilog 文件 | `write_verilog` |

“技术映射”之后，网表里的单元名字就是 Yosys 内置的 **通用门**，如 `$_AND_`、`$_OR_`、`$_MUX_`、`$_DFF_P_`、`$_DFF_PP0_` 等。STA 工具要知道 **每个单元各脚之间的延时**，就要去查 **Liberty 库**；而很多 STA 工具（包括 OpenSTA）对单元名的语法有要求，所以后面我们会对这些名字做一次“改写”，让它们和 Liberty 里的名字一致。

---

## 三、静态时序分析（STA）在做什么

### 3.1 为什么要做 STA

电路在芯片上跑的时候，信号沿导线、穿过门，都会有 **延时**。时钟周期 T 内要完成：

- 从上一个时钟沿 **打出** 的数据，经过 **组合逻辑 + 线** 的延时，要在 **下一个时钟沿到达前** 稳定在触发器 D 端，否则就会采样错（**建立时间违例**）；
- 并且要在时钟沿之后保持足够久，否则也会出错（**保持时间违例**）。

**STA 不跑仿真**，而是根据：
- 网表（哪些门、怎么连）；
- **单元库**（每个门、触发器的引脚延时、建立/保持等）；
- **时钟与约束**（周期、端口）；

把所有 **从触发器到触发器** 的路径都算一遍，找出 **到得最晚** 的路径（关键路径），看它的 **slack**：

- **slack = 要求到达时间 − 实际到达时间**；
- slack &gt; 0：这条路径“赶上了”，时序满足（MET）；
- slack &lt; 0：这条路径“迟到了”，时序违例。

我们做 STA，就是为了回答：**在 10 ns（100 MHz）的时钟下，这条设计有没有 slack &lt; 0 的路径？** 有就不能按 100 MHz 跑。

### 3.2 STA 的输入

| 输入 | 含义 | 在我们项目里 |
|------|------|--------------|
| **网表** | 门级 Verilog，里面是 AND2、DFF 等 **实例** 和连线 | `ysyx_00000000_structural.v` 以及加工后的 `ysyx_00000000_sta.v` |
| **Liberty（.lib）** | 每个单元（AND2、DFF…）的 **引脚方向、延时、建立/保持** 等 | `yosys_gates.lib` |
| **SDC 约束** | 时钟定义（周期、名、接到哪个 port）等 | `constraints.sdc` |

### 3.3 STA 的输出（我们关心的）

- **report_checks**：每类路径的 slack、起止点、路径上的单元；
- **report_wns**：最坏负 slack（WNS），0 表示没有违例；
- **report_tns**：总负 slack（TNS）；
- **report_clock_skew**：时钟偏斜（我们当前是 ideal 时钟，所以可能报 “No launch/capture paths” 之类，可先忽略）。

---

## 四、项目里的文件和流程

### 4.1 文件分布（只看和综合、STA 相关的）

```
npc/
├── vsrc/
│   └── ysyx_00000000.v, EXU.v, ...   # RTL 源文件
└── scripts/
    ├── synth.ys                       # 综合脚本（给 Yosys 用）
    ├── synth_output/
    │   ├── ysyx_00000000_synth.v      # 综合出的“行为/表达式”网表
    │   ├── ysyx_00000000_structural.v # 综合出的“结构”网表（单元实例）
    │   └── ysyx_00000000_sta.v        # 给 OpenSTA 用的网表（由 structural 加工而来）
    └── sta/
        ├── run_sta.sh                 # STA 入口：有 sta 就调 OpenSTA，否则调 estimate
        ├── run_sta.tcl                # OpenSTA 的 Tcl 脚本
        ├── yosys_gates.lib             # 单元库（Liberty）
        ├── constraints.sdc             # 时钟与约束
        ├── estimate_timing.sh          # 无 OpenSTA 时的时序估算
        └── README.md
```

### 4.2 整体数据流（简图）

```
  RTL (ysyx_00000000.v 等)
        │
        ▼
  Yosys (synth.ys)
        │
        ├──► ysyx_00000000_synth.v        （偏“行为”，可仿真、看逻辑）
        │
        └──► ysyx_00000000_structural.v  （结构网表：$_AND_, $_DFF_ 等）
                    │
                    │  run_sta.sh 里的 sed：改单元名、注释 assign { }
                    ▼
              ysyx_00000000_sta.v        （给 OpenSTA 吃的网表）
                    │
                    │  + yosys_gates.lib + constraints.sdc
                    ▼
              OpenSTA (run_sta.tcl)
                    │
                    └──► sta_report.log（slack、关键路径等）
```

---

## 五、每个文件在做什么、为什么要这样

### 5.1 `synth.ys`（综合脚本）

**作用**：告诉 Yosys 读哪些 RTL、做哪些优化、最后写出哪几种网表。

- `read_verilog -sv -I../vsrc/core ...`  
  读入顶层和子模块。`-I` 指定 include 路径，供代码里的 `include` 或相对路径解析用。

- `hierarchy -check -top ysyx_00000000`  
  指定顶层为 `ysyx_00000000`，并检查层次是否完整。

- `proc`  
  把 `always`、`if/else`、`case` 等转成多路选择器、寄存器等，变成“纯组合逻辑 + 寄存器”的图。

- `flatten`  
  把子模块展开，整个设计变成 **一个大模块**，方便后续优化和映射。

- `opt`  
  逻辑优化（消冗余、合并等）。

- `techmap`  
  把 Yosys 内部的 $and、$mux、$dff 等 **映射到最底层的门**：`$_AND_`、`$_OR_`、`$_MUX_`、`$_DFF_P_`、`$_DFF_PP0_`、`$_DFF_PP1_` 等。  
  这些名字是 Yosys 自定义的，和后面 Liberty、OpenSTA 的命名规则不一定兼容，所以我们要再加工一次网表。

- 再 `opt`  
  映射后再优化一次。

- `stat`  
  在终端打印单元统计（多少 `$_AND_`、`$_DFF_` 等），帮助我们了解规模，也给 `estimate_timing.sh` 用。

- `write_verilog -noattr synth_output/ysyx_00000000_synth.v`  
  写出 **第一种** 网表。**不加** `-noexpr` 时，Yosys 会尽量把简单逻辑写成 `assign y = a & b` 这种 **表达式**，对人读、仿真友好，但对 STA 来说，**没有 AND2 这种“单元实例”**，OpenSTA 无法按“门”查延时。

- `write_verilog -noattr -noexpr synth_output/ysyx_00000000_structural.v`  
  写出 **第二种** 网表。**加 `-noexpr`** 表示：**不要把这些门合并成 assign 表达式，保留成单元实例**，例如：
  ```verilog
  AND2 _12345_ ( .A(net_a), .B(net_b), .Y(net_y) );
  ```
  这样 STA 才能看到“这里有一个 AND2”，去 Liberty 里查 A→Y、B→Y 的延时。  
  所以：**要 STA，就必须要有这种“结构网表”**，也就是 `-noexpr` 的作用。

**小结**：  
- `ysyx_00000000_synth.v`：偏行为/表达式，适合仿真、看逻辑；  
- `ysyx_00000000_structural.v`：结构网表，给 STA 用；但里面单元名是 `$_AND_` 这类，OpenSTA 和 Liberty 不一定认，所以要再生成 `ysyx_00000000_sta.v`。

---

### 5.2 `run_sta.sh`（STA 入口脚本）

**作用**：  
- 如果系统里装了 `sta`（OpenSTA）：先根据 `ysyx_00000000_structural.v` 生成 `ysyx_00000000_sta.v`，再调用 `sta run_sta.tcl`，把输出打到 `sta_report.log`。  
- 如果没装 `sta`：就运行 `estimate_timing.sh`，用单元数和经验公式估一个大概的最高频率。

**为什么要从 `structural.v` 再生成一个 `sta.v`？**  
因为：

1. **单元名要能和 Liberty 对上**  
   - Structural 里是：`$_AND_`、`$_OR_`、`$_DFF_P_`、`$_DFF_PP0_`、`$_DFF_PP1_` 等。  
   - Liberty 里我们定义的是：`AND2`、`OR2`、`NOT`、`MUX2`、`XOR2`、`DFF`、`DFF_PP0`、`DFF_PP1`（**不能有 `$`**，否则 OpenSTA 读 .lib 会报错）。  
   - 所以用 `sed` 把网表里的 `\$_AND_` 替换成 `AND2`，`\$_OR_` 替换成 `OR2`，以此类推。**注意**：`$_DFF_PP0_`、`$_DFF_PP1_` 要先换，再换 `$_DFF_P_`，否则会误把 `PP0`、`PP1` 里的 `_P_` 也替换掉。

2. **OpenSTA 的 Verilog 解析器不支持 `assign { a, b } = ...` 这种“左边是拼接”的写法**  
   - 综合后会有少量这种语句（多根线一起赋值）。  
   - 我们无法把它们自动展开成多个 `assign a = ...; assign b = ...;`（需要解析两边，很麻烦），所以退而求其次：**用 `sed` 把整行改成注释**，例如 `// OpenSTA:   assign { ... } = ... ;`。  
   - 被注释掉之后，这些线就“断开了”，理论上时序图会不完整，但 **大多数路径**（尤其是经过 AND2、OR2、DFF 等单元的关键路径）仍然连通，所以 **还是能算出 slack 和关键路径**；只是如果某条 path 恰好依赖被注释的那几根线，可能会漏报或不准。在我们的设计中，这些 `assign { }` 多用于内部拆分，对当前看到的 critical path 影响不大。

**sed 做的事（顺序很重要）**：

```text
\$_DFF_PP0_  → DFF_PP0
\$_DFF_PP1_  → DFF_PP1
\$_DFF_P_    → DFF
\$_AND_      → AND2
\$_OR_       → OR2
\$_NOT_      → NOT
\$_MUX_      → MUX2
\$_XOR_      → XOR2
```

以及：  
- 行首为 `assign` 且接着是 `{` 的整行，在行首插入 `// OpenSTA: `，等价于注释。

---

### 5.3 `run_sta.tcl`（OpenSTA 的 Tcl 脚本）

**作用**：按固定顺序调用 OpenSTA 的命令：读库、读网表、连接设计、读约束、报时序。

- `read_liberty $LIB`  
  读 Liberty，得到每个 cell 的 pin、延时、setup/hold 等。  
  我们的库是 `yosys_gates.lib`。

- `read_verilog $NETLIST`  
  读网表。变量 `NETLIST` 优先取 `ysyx_00000000_sta.v`（若存在），否则用 `ysyx_00000000_structural.v`。  
  这样，只要 `run_sta.sh` 生成了 `sta.v`，就会自动用加工好的版本。

- `link_design ysyx_00000000`  
  把刚读入的 Verilog 和已读的 Liberty 做“链接”：网表里每个实例（如 `AND2`、`DFF`）都去 Liberty 里找同名 cell，把 **pin 的延时、时序弧** 挂上去。  
  如果名字对不上，就会报 “module xxx not found” 或当成黑盒，没有延时，STA 结果就不准。

- `read_sdc $SDC`  
  读约束文件，里面主要是 `create_clock`，告诉 STA：  
  - 端口 `clock` 上有一个名叫 `clk` 的时钟；  
  - 周期 10 ns（100 MHz）。

- `report_checks -path_delay max`  
  按“最大路径延时”报建立时间类检查，会列出 slack、起点、终点、路径上的单元。

- `report_checks -path_delay max -format full_clock_expanded -digits 3`  
  同上，但格式更细、小数位更多，便于看路径细节。

- `report_wns`、`report_tns`  
  最差负 slack、总负 slack。  
  WNS=0、TNS=0 表示当前约束下没有违例。

- `report_clock_skew`  
  时钟偏斜。我们用的是 ideal 时钟，没有做时钟树，所以这里可能报 “No launch/capture paths” 等，可以不管。

- `if {[catch { report_clocks } err]} { ... }`  
  有的 OpenSTA 版本没有 `report_clocks` 这个命令，直接写 `report_clocks` 会报 “invalid command name”。  
  用 `catch` 包起来：有则执行，没有则打印一句提示，避免整个 tcl 报错退出。

---

### 5.4 `constraints.sdc`（时序约束）

**作用**：告诉 STA “时钟长什么样、接到哪里”。

- `create_clock -name clk -period 10.0 [get_ports clock]`  
  - `[get_ports clock]`：在网表里找到顶层端口 `clock`；  
  - `-name clk`：给这个时钟起名叫 `clk`，后面 `report_checks`、`report_wns` 会按 `clk` 分组；  
  - `-period 10.0`：周期 10 ns，即 100 MHz。  
  STA 会按 10 ns 算：launch 在 0 ns，capture 在 10 ns，要求数据在 10 ns 前（再减去 setup）到达 D 端。

- 被注释的 `set_input_delay`、`set_output_delay`  
  更完整的约束还会给输入/输出端口加“相对时钟”的 delay，表示片外逻辑的延时。  
  我们当前只关心片内路径，所以先不设；若以后接真实外设，再按数据手册补。

**小结**：SDC 最核心的就是这句 `create_clock`；没有它，STA 不知道周期是多少，也无法算 required time。

---

### 5.5 `yosys_gates.lib`（Liberty 单元库）

**作用**：为 AND2、OR2、NOT、MUX2、XOR2、DFF、DFF_PP0、DFF_PP1 这些 **单元** 定义：

- 引脚方向（input/output）、  
- 组合逻辑的 **引脚到引脚的延时**（intrinsic_rise / intrinsic_fall）、  
- 触发器的 **时钟→Q 延时**、**D 相对 C 的 setup/hold**、  
- 以及库级 **slew/transition 的 threshold**（后面说）。

这样 OpenSTA 才能：  
- 在一条 path 上，从上一级单元的 output 到下一级单元的 input，查到“这段门延时”是多少；  
- 在 D 端，根据 C 的边沿和 setup/hold，算 required time。

**为什么不能沿用 Yosys 的 `$_AND_` 当 cell 名？**  
- Liberty 的 `cell( )` 里通常只允许字母、数字、下划线等，**`$` 在很多解析器里是特殊字符**，会报 “unexpected $undefined” 之类的语法错误。  
- 所以我们 **在 .lib 里不用 `$`**，改用在网表里用 `sed` 替换成 AND2、OR2 等合法名字；**两边统一**，`link_design` 才能正确找到每个 cell。

**库级 threshold（input/output/slew 的百分比）**  
- OpenSTA 报错：`Library yosys_gates is missing one or more thresholds`。  
- 原因：Liberty 规范里，库可以定义“在多少百分比 Vdd 处量上升/下降延时、量 slew”。  
- 我们补了：  
  - `input_threshold_pct_rise/fall`、`output_threshold_pct_rise/fall`（例如 50）；  
  - `slew_lower_threshold_pct_rise/fall`、`slew_upper_threshold_pct_rise/fall`（例如 20、80）。  
- 这些是 **占位数值**，因为我们没有真实工艺的波形；用 50、20/80 这类常用值，只是为了让 OpenSTA 能 **解析通过** 并做延时计算，得到的 **绝对频率** 仍不具工艺意义，但 **路径结构、相对快慢、slack 正负** 是有参考价值的。

**组合逻辑单元（AND2、OR2、NOT、MUX2、XOR2）**  
- 每个 output pin（如 Y）下有：  
  - `timing() { related_pin : "A"; intrinsic_rise : 0.1; intrinsic_fall : 0.1; }`  
  表示：A 变化导致 Y 变化的延时（这里简化为固定 0.1 ns）。  
- 多输入的门（如 AND2）会对 A、B 各写一个 `timing`，这样无论信号从 A 还是 B 进来，STA 都能查到延时。

**触发器（DFF、DFF_PP0、DFF_PP1）**  
- `ff(IQ, IQN) { clocked_on : "C"; next_state : "D"; clear : "R"; }` 等：  
  表示这是由 C 时钟驱动的 D 触发器，有的有复位 R（DFF_PP0 为 clear，DFF_PP1 为 preset）。  
- **Q 的 timing**：`related_pin : "C"`，`intrinsic_rise/fall`：  
  表示 **clock-to-Q**：时钟沿到 Q 变化的延时（我们设 0.05 ns）。  
- **D 的 timing**：  
  - `timing_type : setup_rising`：D 必须在 C 的上升沿前 `intrinsic_rise/fall` 时间稳定；  
  - `timing_type : hold_rising`：D 必须在 C 的上升沿后保持 `intrinsic_rise/fall` 时间。  
  没有 setup/hold，STA 不知道“数据最晚要什么时候到、最早什么时候能变”，required time 就算不出来，**就不会有正确的 slack，也常常导致 “No paths found”**。  
  我们给的 0.05、0.02 是占位，只为让 STA 能跑通，真实值要从工艺库来。

**为什么要有 DFF_PP0、DFF_PP1，而不是只有一个 DFF？**  
- Yosys 的 `techmap` 会生成多种 D 触发器：  
  - 仅 D、C、Q：`$_DFF_P_`；  
  - 带高有效复位（clear）：`$_DFF_PP0_`；  
  - 带高有效置位（preset）：`$_DFF_PP1_`。  
- 它们在 Liberty 里的 `ff` 定义不同（`clear` / `preset`），引脚也不同（多一个 R）。  
- 所以要在 .lib 里各定义一个 cell，并在 `run_sta.sh` 的 sed 里 **分别** 把 `\$_DFF_PP0_`、`\$_DFF_PP1_`、`\$_DFF_P_` 换成正则匹配到的 DFF_PP0、DFF_PP1、DFF，保证 netlist 和 lib 一一对应。

---

### 5.6 `estimate_timing.sh`（没有 OpenSTA 时的时序估算）

**作用**：当系统里没有 `sta` 时，用 **综合 stat 的单元数** 和 **经验公式**，估一个“大概能跑多快”。

- 从 `synth_output/synth.log`（或类似路径）里 **grep** 出 `$_AND_`、`$_OR_`、`$_MUX_`、`$_NOT_`、`$_XOR_`、`$_DFF_PP0_`、`$_DFF_PP1_`、`$_DFF_P_` 的个数；若找不到或为空，就用默认值（与我们 stat 结果一致）。  
- 假定：  
  - **组合逻辑深度** 约 35 级（经验值，表示从寄存器出发经过约 35 个门再回到寄存器）；  
  - **每级门延时** 0.1 ns；  
  - **触发器 clk-to-Q** 0.05 ns。  
- 关键路径 ≈ `35 * 0.1 + 0.05` ns，最高频率 ≈ `1000 / 关键路径` MHz。  

**局限性**：  
- 深度 35 是拍脑袋的，和真实 critical path 的级数可能差很多；  
- 也没考虑 MUX、XOR 比 AND/OR 稍慢等。  
所以只适合 **没有 OpenSTA 时** 看个数量级；**有 OpenSTA 时，以 sta_report.log 为准**。

---

## 六、我们做了哪些修改，以及原因汇总

| 修改点 | 在哪个文件 | 原因 |
|--------|------------|------|
| 增加 `write_verilog -noattr -noexpr ... structural.v` | `synth.ys` | STA 需要 **结构网表**（单元实例），不能只有 `assign` 表达式；`-noexpr` 才能保留 AND2、DFF 这类实例。 |
| 用 `sed` 把 `\$_AND_` 等替换成 `AND2` 等 | `run_sta.sh` | Liberty 里不能用 `$` 做 cell 名；OpenSTA 读 .lib 会报错；网表和 .lib 的 cell 名必须一致，`link_design` 才能正确挂延时。 |
| 用 `sed` 注释 `assign { ... } = ...` 的整行 | `run_sta.sh` | OpenSTA 的 Verilog 解析器不支持 LHS 为 `{ }` 的 `assign`；注释掉后，STA 仍能分析大部分路径，只是少数依赖这些线的 path 可能不全。 |
| 在 Liberty 里把 `$_AND_` 等改成 `AND2` 等 | `yosys_gates.lib` | 同上：避免 `$`，并与 `run_sta.sh` 的替换一致。 |
| 在 Liberty 里增加 `input/output_threshold_pct_*`、`slew_*_threshold_pct_*` | `yosys_gates.lib` | 满足 OpenSTA 对库“必须提供这些 threshold”的检查，否则 `read_liberty` 报错。 |
| 为 DFF 的 D 端增加 `setup_rising`、`hold_rising` | `yosys_gates.lib` | 没有 setup/hold，STA 算不出 capture 处的 required time，常导致 “No paths found”；加上后就能报出 slack 和路径。 |
| 优先读 `ysyx_00000000_sta.v`，没有再读 `structural.v` | `run_sta.tcl` | 让 OpenSTA 自动用“已加工、能和 .lib 对上”的 `sta.v`，减少手工步骤。 |
| 用 `catch` 包住 `report_clocks` | `run_sta.tcl` | 部分 OpenSTA 版本没有 `report_clocks`，直接调会 “invalid command name”；`catch` 后不影响其他报告。 |
| `create_clock -period 10 [get_ports clock]` | `constraints.sdc` | 定义 100 MHz 时钟，STA 才能按 10 ns 算 required time 和 slack。 |

---

## 七、怎么运行、怎么读结果

### 7.1 运行

```bash
cd /path/to/npc

# 1. 综合（若没跑过，或 RTL 改过）
make synth-ysyx

# 2. 时序分析（有 OpenSTA 会跑 STA，没有会跑 estimate_timing.sh）
make sta
```

或直接进 `scripts/sta` 执行 `./run_sta.sh`。

### 7.2 看 STA 报告（`sta_report.log`）

- **`report_checks -path_delay max`** 会列出一条（或数条）**最慢的路径**，例如：  
  - `Startpoint: clock (clock source 'clk')`  
  - `Endpoint: EXU.wdata_reg[0] (rising edge-triggered flip-flop clocked by clk)`  
  下面是一串 `Delay / Time / Description`，从时钟沿、经过的 DFF、AND2、OR2、MUX2、NOT 等，一直到 endpoint 的 D；最后有：  
  - `data arrival time`（数据真正到 D 的时间）；  
  - `data required time`（按要求最晚到 D 的时间，和 period、setup 有关）；  
  - **`slack (MET)`** 或 **`slack (VIOLATED)`**。  

- **`wns`**：最坏负 slack；为 0 表示在当前约束下 **没有建立时间违例**。  
- **`tns`**：总负 slack；为 0 表示没有违例。  

若 `slack (MET)` 且 `wns 0.00`、`tns 0.00`，则可认为：**在 10 ns（100 MHz）下，这条设计时序满足**。  
若想试探“最高能跑多少”，可把 `constraints.sdc` 里的 `-period 10.0` 改小（如 9.0、8.5），再 `make sta`，看 `wns` 何时变负、`slack` 何时变 VIOLATED。

---

## 八、局限和延伸

- **Liberty 是占位的**：`yosys_gates.lib` 里的 0.1 ns、0.05 ns 等是我们随手给的，**不是** 某工艺库的真实参数。因此：  
  - **绝对频率**（例如“能跑 100 MHz”）不能直接用于流片；  
  - **路径结构、谁最慢、slack 正负** 仍有参考价值，可用来做优化方向（插寄存器、改结构等）。  

- **要得到工艺相关的结果**：需要换用该工艺的 **Liberty**（.lib），并在综合时用 **abc -liberty** 等把 RTL 映射到该库的 cell；我们当前只做到 Yosys 的 `techmap` 通用门 + 自写一个小 lib，作为学习和流程打通之用。  

- **`assign { } =` 被注释**：会令少量内部连线在 STA 里“断掉”，若你的 critical path 恰在其中，有可能漏报；一般可以先接受，若以后发现和仿真/实际上板不一致，再考虑改综合或手写等价 `assign` 拆分。  

- **更多约束**：  
  - 若设计有多个时钟，需在 SDC 里为每个 `create_clock`，并视情况设 `set_clock_groups` 等；  
  - 若和外设/存储器有接口，需 `set_input_delay`、`set_output_delay`、`set_false_path` 等。  
  这些可在学过 STA 基础后，按项目需求逐步加。

---

## 九、小结

- **综合**：把 RTL 变成门级网表；我们用 Yosys 的 `synth.ys`，并特意用 `-noexpr` 写出 **结构网表**，以便给 STA 用。  
- **STA**：用网表 + Liberty + SDC，算 slack、关键路径；我们用 OpenSTA，通过 `run_sta.sh` 和 `run_sta.tcl` 自动化。  
- **为让 OpenSTA 能跑起来**，我们：  
  - 把网表里的 `$_AND_` 等换成 AND2 等，并注释掉不支持的 `assign { } =`；  
  - 在 Liberty 里用合法 cell 名、补全 threshold、为 DFF 加上 setup/hold；  
  - 在 SDC 里 `create_clock` 定义 100 MHz。  
- 最终 `make sta` 能得到 **slack、WNS/TNS、关键路径**；在现有占位库下，可认为 **10 ns 周期时序满足**；若换工艺 Liberty 并做正确映射，则可得到更有工艺意义的频率上界。
